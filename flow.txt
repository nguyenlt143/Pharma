
Supplier → Warehouse
•	Tạo movement nhập
•	Tạo batch
•	Ghi tồn kho warehouse
Warehouse → Branch
•	Tạo movement chuyển kho
•	Giảm tồn warehouse
•	Tăng tồn branch
Branch → Customer
•	Tạo invoice
•	Tạo invoice_details: mỗi detail sẽ link tới một record trong bảng `inventory` để xác định chính xác lô hàng và sản phẩm được bán.
•	Giảm tồn kho `inventory` của branch theo `inventory_id` đã bán.

•  Các mối quan hệ Entity chính cần lưu ý
a. InvoiceDetail → Inventory: Đây là liên kết quan trọng nhất khi bán hàng. `InvoiceDetail` không còn lưu trực tiếp `variant_id` hay `batch_id`. Thay vào đó, nó tham chiếu đến `inventory_id`.
b. Inventory → MedicineVariant, Batch, Branch: Bảng `inventory` đóng vai trò trung tâm, kết nối sản phẩm (`MedicineVariant`), lô hàng (`Batch`), và vị trí lưu trữ (`Branch`).
c. Logic truy vấn: Khi cần lấy thông tin sản phẩm từ một hóa đơn, phải join qua chuỗi: `Invoice` → `InvoiceDetail` → `Inventory` → `MedicineVariant`.

•  Tổng quan — các “giá” liên quan và vai trò ngắn gọn
a. supplier_price (giá nhà cung cấp) — Giá gốc từ nhà cung cấp, được lưu trong `inventory_movement_details.snap_cost` để kiểm toán.
b. movement_price (`inventory_movement_details.price`) — Giá nhập cho kho/chi nhánh đích tại thời điểm di chuyển. Giá này được dùng để thiết lập `costPrice` cho hàng tồn kho mới.
c. inventory_cost_price (`inventory.costPrice`) — Giá vốn của một mặt hàng cụ thể tại một chi nhánh/kho cụ thể. Giá này được dùng để tính giá trị tồn kho (`quantity` × `costPrice`).
d. branch_price (`prices.branch_price`) — Giá mà kho tổng bán cho chi nhánh.
e. sale_price (`prices.sale_price`) — Giá mà chi nhánh bán ra cho khách hàng cuối cùng (ghi vào hóa đơn).
f. snap_cost — Chỉ dùng cho mục đích kiểm toán và báo cáo lợi nhuận gốc. Không ảnh hưởng đến logic tính giá trị tồn kho.

•  Giai đoạn 1 — Khi nhà cung cấp xuất hàng (Supplier → Warehouse)
a. Hệ thống tạo `inventory_movements` (loại `SUP_TO_WARE`) và các `inventory_movement_details` tương ứng.
b. Trong `inventory_movement_details`: `price` (giá nhập kho) sẽ bằng `snap_cost` (giá từ nhà cung cấp).
c. Mỗi lần nhập hàng từ nhà cung cấp sẽ tạo một bản ghi `batch` mới trong hệ thống để theo dõi giá vốn. Ngay cả khi mã lô từ nhà cung cấp (`batch_code`) giống nhau giữa các lần nhập, hệ thống sẽ tạo các `batch.id` khác nhau.
d. Khi ghi nhận vào `inventory` của kho: một bản ghi `inventory` mới được tạo ra với `costPrice` được gán bằng `movement_details.price`.

•  Giai đoạn 2 — Khi chuyển hàng từ Kho tổng → Chi nhánh (Warehouse → Branch)
a. Tạo `inventory_movements` (loại `WARE_TO_BR`) và `inventory_movement_details`, chọn `batch_id` theo quy tắc (ví dụ: FIFO/FEFO).
b. Trong `inventory_movement_details`:
   - `price` := Giá được xác định theo quy tắc nghiệp vụ . Đây là giá vốn mới cho chi nhánh.
   - `snap_cost` := giữ nguyên giá gốc từ Giai đoạn 1 để tính lợi nhuận.
c. Khi chi nhánh nhận hàng: Cập nhật hoặc thêm mới `inventory` tại chi nhánh với `costPrice` := `movement_details.price`.
d. Lợi nhuận nội bộ của kho tổng = `movement_details.price` - `snap_cost`.

•  Giai đoạn 3 — Lưu kho & Quản lý giá vốn (Inventory Lifecycle)
a. `inventory.costPrice` là giá vốn cho một lô hàng (batch) cụ thể tại một chi nhánh cụ thể. Đây là nguồn chính xác để định giá tồn kho.
b. Hệ thống sử dụng phương pháp "Định danh cụ thể" (Specific Identification): Mỗi bản ghi `inventory` là một lớp chi phí (cost layer) riêng biệt, không tính giá trị trung bình. Khi nhập thêm hàng, một bản ghi `inventory` mới sẽ được tạo ra với `costPrice` tương ứng.
c. Xử lý các trường hợp nhập hàng:
   - **Nhập cùng 1 lô, 2 lần cùng giá**: Hệ thống sẽ tìm một bản ghi `inventory` hiện có với cùng `variant_id`, `batch_id`, `branch_id` và `costPrice`. Nếu tìm thấy, hệ thống sẽ cộng dồn số lượng vào bản ghi đó. Nếu không, một bản ghi mới sẽ được tạo.
   - **Nhập cùng 1 lô, 2 lần khác giá**: Vì `costPrice` khác nhau, hệ thống sẽ tạo ra một bản ghi `inventory` mới. Điều này đảm bảo mỗi "lớp chi phí" (cost layer) được theo dõi riêng biệt.
   - **Nhập khác lô**: Đây là trường hợp tiêu chuẩn, mỗi lô sẽ có một bản ghi `inventory` riêng với `costPrice` của nó.

•  Giai đoạn 4 — Quy tắc lấy giá bán khi tạo hóa đơn (Invoice)
a. Giá bán cho khách hàng được lấy từ `prices.sale_price`.
b. Lợi nhuận của chi nhánh = `invoice_details.price` (giá bán thực tế) - `invoice_details.inventory.costPrice` (giá vốn của lô hàng đã bán tại chi nhánh).
c. Quy tắc ưu tiên lấy giá bán:
   1. Nếu có giá trong bảng `prices` cho `branch_id` cụ thể và trong khoảng thời gian hiệu lực → Dùng giá đó.
   2. Nếu không, tìm giá bán chung (global) trong bảng `prices` (không có `branch_id`).
   3. Nếu không có, có thể fallback về một giá mặc định trên sản phẩm.
d. Khuyến mãi/Giảm giá: `invoice_details.price` sẽ lưu giá bán thực tế sau khi đã áp dụng giảm giá. Lợi nhuận sẽ được tính dựa trên giá này.

•  Xử lý các trường hợp đặc biệt
a. Thay đổi giá bán: Nếu `prices.sale_price` thay đổi, nó không tự động cập nhật `inventory.costPrice`. Giá vốn tồn kho chỉ thay đổi khi có hoạt động nhập hàng.
b. Trả hàng (Returns/Refunds): Khi khách trả hàng, có thể tạo một bản ghi `stock_adjustments` hoặc hóa đơn âm. Giá vốn khi nhập lại hàng vào kho sẽ tuân theo chính sách của công ty (ví dụ: phục hồi giá vốn ban đầu).

•  Khuyến nghị thiết kế
a. Để theo dõi chi phí chính xác, mỗi lớp chi phí (cost layer) nên được ghi nhận riêng, thay vì ghi đè `costPrice` theo phương pháp trung bình. Điều này giúp việc truy vết giá vốn theo FIFO/LIFO dễ dàng hơn.
b. Tách biệt logic giá bán (`prices`) khỏi giá vốn (`inventory`). Không dùng `prices` để định giá lại tồn kho một cách tự động.

Tổng kết các loại giá:
•	`price` (trong movement_details): Giá nhập tại kho/chi nhánh đích.
•	`snap_cost` (trong movement_details): Giá vốn gốc từ nhà cung cấp, dùng để kiểm toán.
•	`costPrice` (trong inventory): Giá vốn hiện tại của hàng tồn kho tại một địa điểm cụ thể.
•	`branch_price` (trong prices): Giá kho tổng bán cho chi nhánh.
•	`sale_price` (trong prices): Giá chi nhánh bán cho khách hàng.

